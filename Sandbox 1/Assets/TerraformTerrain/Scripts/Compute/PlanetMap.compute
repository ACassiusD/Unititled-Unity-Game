#pragma kernel CSMain
//#include "/Includes/Noise.compute"
//#include "/Includes/Pnoise.compute"

RWTexture3D<float> DensityTexture;
int textureSize; //Size of the 3D texture on 1 axis
float planetSize; //Diamter of the planet
float noiseScale;
float noiseHeightMultiplier;

//Debug buffer
RWStructuredBuffer<float> debugBuffer;


//float fractalBrownianMotion(int numLayers, float lacunarity, float persistence, float scale, float3 pos)
//{
//	float noise = 0;
//	float frequency = scale / 100;
//	float amplitude = 1;

//	for (int i = 0; i < numLayers; i ++) {
		
//		//Simplex noise value (-1 to 1) scaled by the frequency
//        float scaledSimplexValue = snoise(pos * frequency);
		
//		//Multiplying noise by 2 scales the range to [-2, 2].
//		//Subtracting 1 shifts this range to [-3, 1].
//		//Taking the absolute value of this result maps the range to [1, 3].
//		//subtracting this from 1 inverts and normalizes the range to [0, 2]
//        float n = 1 - abs(scaledSimplexValue * 2 - 1);
		
//		noise += n * amplitude;

//		amplitude *= persistence;
		
//		frequency *= lacunarity;
//	}

//	return noise;
//}

////Spherical Planet
//float calculateDensity(int3 gridPoint)
//{
//    float3 worldPos = (gridPoint / float(textureSize - 1.0) - 0.5f) * planetSize;

//	//Radius of the planet
//    float halfS = planetSize / 2;
	
//	//maximum distance from the center of the sphere to its surface. The radius of the sphere.
//    float radius = length(float3(halfS, halfS, halfS));

//	//small adjustment factor 
//    float fudge = 1;
	
//	//Distance from the center of the sphere to the current point
//    float distanceFromCenter = length(worldPos);
	
//    float density = distanceFromCenter / (radius + fudge) - 0.5;

//	// Noise
//    float noise = fractalBrownianMotion(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;

//    density += noise;

//    return density;
//}










float wglnoise_mod(float x, float y)
{
    return x - y * floor(x / y);
}

float2 wglnoise_mod(float2 x, float2 y)
{
    return x - y * floor(x / y);
}

float3 wglnoise_mod(float3 x, float3 y)
{
    return x - y * floor(x / y);
}

float4 wglnoise_mod(float4 x, float4 y)
{
    return x - y * floor(x / y);
}

float2 wglnoise_fade(float2 t)
{
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float3 wglnoise_fade(float3 t)
{
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float wglnoise_mod289(float x)
{
    return x - floor(x / 289) * 289;
}

float2 wglnoise_mod289(float2 x)
{
    return x - floor(x / 289) * 289;
}

float3 wglnoise_mod289(float3 x)
{
    return x - floor(x / 289) * 289;
}

float4 wglnoise_mod289(float4 x)
{
    return x - floor(x / 289) * 289;
}

float3 wglnoise_permute(float3 x)
{
    return wglnoise_mod289((x * 34 + 1) * x);
}

float4 wglnoise_permute(float4 x)
{
    return wglnoise_mod289((x * 34 + 1) * x);
}


float ClassicNoise_impl(float2 pi0, float2 pf0, float2 pi1, float2 pf1)
{
    pi0 = wglnoise_mod289(pi0); // To avoid truncation effects in permutation
    pi1 = wglnoise_mod289(pi1); //wglnoise_mod289(float2)

    float4 ix = float2(pi0.x, pi1.x).xyxy;
    float4 iy = float2(pi0.y, pi1.y).xxyy;
    float4 fx = float2(pf0.x, pf1.x).xyxy;
    float4 fy = float2(pf0.y, pf1.y).xxyy;

    float4 i = wglnoise_permute(wglnoise_permute(ix) + iy); //wglnoise_permute(float4)

    float4 phi = i / 41 * 3.14159265359 * 2;
    float2 g00 = float2(cos(phi.x), sin(phi.x));
    float2 g10 = float2(cos(phi.y), sin(phi.y));
    float2 g01 = float2(cos(phi.z), sin(phi.z));
    float2 g11 = float2(cos(phi.w), sin(phi.w));

    float n00 = dot(g00, float2(fx.x, fy.x));
    float n10 = dot(g10, float2(fx.y, fy.y));
    float n01 = dot(g01, float2(fx.z, fy.z));
    float n11 = dot(g11, float2(fx.w, fy.w));

    float2 fade_xy = wglnoise_fade(pf0); //wglnoise_fade(float2)
    float2 n_x = lerp(float2(n00, n01), float2(n10, n11), fade_xy.x);
    float n_xy = lerp(n_x.x, n_x.y, fade_xy.y);
    return 1.44 * n_xy;
}

// Classic Perlin noise
float ClassicNoise(float2 p)
{
    float2 i = floor(p);
    float2 f = frac(p);
    return ClassicNoise_impl(i, f, i + 1, f - 1);
}

float PerlinNoiseTest()
{
    float x = 50.0f;
    return x;
}

// Classic Perlin noise, periodic variant
float PeriodicNoise(float2 p, float2 rep)
{
    float2 i0 = wglnoise_mod(floor(p), rep); //wglnoise_mod(float x, float y)
    float2 i1 = wglnoise_mod(i0 + 1, rep);
    float2 f = frac(p);
    return ClassicNoise_impl(i0, f, i1, f - 1);
}

float tester()
{
    float x = 50.0f;
    return x;
}

float calculateDensityCubicWorld(int3 gridPoint, int surfaceLevel){

    float defaultAirDensity = 0.05;
    float defaultSolidDensity = -0.05;
    float perlinNoiseVal = 0;
    float pnoise = 0;

    ////Use a sin function
    //float frequency = 0.2;
    //int amplitude = 3;
    //float xOffset = sin(gridPoint.x * frequency) * amplitude;
    //float zOffset = sin(gridPoint.z * frequency) * amplitude;
    //int surface = surfaceLevel + xOffset + zOffset;


    //Use perlin noise 
    float scale = 0.033423; // Adjust these scale factors as needed
    float2 scaledInput = float2((float) gridPoint.x * scale, (float) gridPoint.z * scale);
    pnoise = ClassicNoise(scaledInput);
    int surface = surfaceLevel + (pnoise * 20);
  
    
    return (gridPoint.y < surface) ? defaultSolidDensity : defaultAirDensity;
}




//Cubic noise Planet 
//float calculateDensity(int3 gridPoint)
//{
//	// Convert texture grid point to world position, normalized to [-0.5, 0.5] (centering the planet at 0,0,0)
//    float3 worldPos = (gridPoint / float(textureSize - 1) - 0.5f) * planetSize;

//    // Return noise value
//    float noise = fractalBrownianMotion(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;

//    return noise;
//}


// id = Thread id || the unique 3d grid position in the texture.
// The isolevel is set to 0, values below 0 count as solid points of terrain, values above 0 count as empty space.
[numthreads(8, 8, 8)] //Size of each individial thread Group  8×8×8=512 threads
void CSMain(int3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID)
{
    float defaultAirDensity = 0.05;
    float defaultSolidDensity = -0.05;
	int halfTextureSize = textureSize / 2;

	//If we are on a thread that is outside the texture, return.
	//Handling the extra threads created from rouding up for the thread groups.
	if (id.x >= textureSize || id.y >= textureSize || id.z >= textureSize) {
		return;
	}
	
	float density = 0;
	const int borderBoundry = 1;
	
	//Create a border around the texture set as empty space (for visual rendering purposes)
	//If the point is not in the border boundry, calculate its density
    if (id.x >= textureSize - borderBoundry || id.y >= textureSize - borderBoundry || id.z >= textureSize - borderBoundry){
        density = defaultAirDensity;
    }
    else if (id.x <= borderBoundry || id.y <= borderBoundry || id.z <= borderBoundry){
        density = defaultAirDensity;
    }
    else{
		//Calculate the points density
        density = calculateDensityCubicWorld(id, halfTextureSize);
    }
	
    
    
    //Write to the debug buffer for the first 1000 threads dispatched 
    uint globalIndex = id.x +
                       id.y * 8 +
                       id.z * 8 * 8 +
                       groupId.x * 8 * 8 * 8 +
                       groupId.y * 8 * 8 * 8 * 12 +
                       groupId.z * 8 * 8 * 8 * 12 * 12;
    // Check if the global index is within the first 1000
    if (globalIndex < 1000)
    {
        float scaleX = 0.1; // Adjust these scale factors as needed
        float scaleZ = 0.1;

        // Assuming 'maxValueX' and 'maxValueZ' are the maximum values id.x and id.z can take
        float2 scaledInput = float2((float) id.x * scaleX, (float) id.z * scaleZ);
        
        debugBuffer[globalIndex] = ClassicNoise(scaledInput);
    }
    
    
    
	//Set the density
	DensityTexture[id] = density; 
}
