using JetBrains.Annotations;
using System.Runtime.Remoting.Lifetime;
using UnityEngine;

//Uses compute shaders to generate a 3D raw density map of the terrain and optinally a processed (blurred) density map
public class GenTest : MonoBehaviour
{
	[Header("Generation Parameters")]
    public float terrainBoundarySize = 500; //The bounding box of the terrain measured in unity units. (Imagine a grid boundry where the terrain is generated within)
    public int chunksPerDimension = 10; //The number of chunks in the X,Y,Z (i.e. 10^3=100 chunks total)
    public int numDensityPointPerChunkAxis = 10; //The number of points we can sample dentisy values from on each axis of a chunk
    public float isoLevel = 0f;
	public bool useFlatShading;
	public float noiseScale;
	public float noiseHeightMultiplier;
	public bool blurMap;
	public int blurRadius = 3;

	[Header("References")]
	public ComputeShader meshCompute;
	public ComputeShader densityCompute;
	public ComputeShader blurCompute;
	public ComputeShader editCompute;
	public Material material;

    //Small manageable pieces of the terrain with coordinates, center, size, and a GameObject for mesh rendering.
    Chunk[] chunkArray;

    //Buffers
    ComputeBuffer triangleBuffer; //Stores the vertices generated by the Marching Cubes algorithm, an array of VertexData structs. GPU based
    ComputeBuffer triCountBuffer; //Small, efficiently structured Intermediary buffer, Only stores a single integer — the # of elements in triangleBuffer. Serves as bridge for data transfer between GPU and CPU

	//For compute shader output
    [HideInInspector] public RenderTexture rawDensityTexture;
	[HideInInspector] public RenderTexture processedDensityTexture;

	VertexData[] vertexDataArray;

	RenderTexture originalMap;

    //For logging to Debugger.
    int totalVerticesCount;
    int totalTriangleCount;

	//Timers
    System.Diagnostics.Stopwatch timer_fetchVertexData;
    System.Diagnostics.Stopwatch timer_processVertexData;

    //Debugging terraform edit sphere
    private Vector3 gizmoPosition;
    private float gizmoRadius;

    void Start()
	{
        InitTextures(); // Create 3D textures to store density values of terrain generated by noise
		CreateBuffers(); // Create buffers to store triangle count and triangle vertices
        CreateChunks(); // Create the chunks that will be used to render the terrain to. These contain coordinates, center, size etc to represent a point in our games world

		var stopWatch = System.Diagnostics.Stopwatch.StartNew(); //For timing how long it takes to generate the terrain
		
		GenerateAllChunks(); //TODO: Finisgh Study this + density compute shader.
		
		Debug.Log("Generation Time: " + stopWatch.ElapsedMilliseconds + " ms");
		ComputeHelper.CreateRenderTexture3D(ref originalMap, processedDensityTexture);
		ComputeHelper.CopyRenderTexture3D(processedDensityTexture, originalMap);
	}

	//Create the render textures that represent that terrain
	//Set the textures on the compute shaders to be rendered to
	void InitTextures()
	{
		//Calculate axis length of the texture that holds the density values of the terrain 
        // i.e. 10 chunks per dimension with 10 points per chunk axis = 10 * (10-1) + 1 = 91
        int densityTextureAxisLength = chunksPerDimension * (numDensityPointPerChunkAxis - 1) + 1;
        
        Debug.Log(densityTextureAxisLength);

        //Create the 3D textures using densityTextureAxisLength as the x,y,z axis length
        Create3DTexture(ref rawDensityTexture, densityTextureAxisLength, "Raw Density Texture"); //raw density map
		Create3DTexture(ref processedDensityTexture, densityTextureAxisLength, "Processed Density Texture"); //blurred density map

		if (!blurMap){
			processedDensityTexture = rawDensityTexture;
		}

		// Set textures on compute shaders
		densityCompute.SetTexture(0, "DensityTexture", rawDensityTexture);
		editCompute.SetTexture(0, "EditTexture", rawDensityTexture);
		blurCompute.SetTexture(0, "Source", rawDensityTexture);
		blurCompute.SetTexture(0, "Result", processedDensityTexture);
		meshCompute.SetTexture(0, "DensityTexture", (blurCompute) ? processedDensityTexture : rawDensityTexture);
	}

    /// <summary>
    /// Creates a 3D texture with the specified axis size and name.
    /// </summary>
    /// <param name="texture">The RenderTexture to create or update.</param>
    /// <param name="axisLength">The size of the texture on a single axis.</param>
    /// <param name="name">The name of the texture.</param>
    void Create3DTexture(ref RenderTexture texture, int axisLength, string name)
    {
        //Each point in the 3D texture (which is defined by a coordinate on all three axes) stores a single 32-bit floating-point number
        var format = UnityEngine.Experimental.Rendering.GraphicsFormat.R32_SFloat;

        if (texture == null || !texture.IsCreated() || texture.width != axisLength || texture.height != axisLength || texture.volumeDepth != axisLength || texture.graphicsFormat != format)
        {
            //frees the memory used by the texture
            if (texture != null)
                texture.Release();

            // Set texture height, width, and depthbuffer. Also set the format to float.
            // The depth buffer is used in rendering to handle which objects are in front of others, but it's not relevant for the texture's 3D structure.
            const int numBitsInDepthBuffer = 0;
            texture = new RenderTexture(axisLength, axisLength, numBitsInDepthBuffer);
            texture.graphicsFormat = format;

			// Add third dimension (of x,y,z) to texture and tell unity to treat it as a 3D texture
            texture.volumeDepth = axisLength;
            texture.dimension = UnityEngine.Rendering.TextureDimension.Tex3D;

            // Enable random write access for the texture to allow compute shaders to write data to any location.
            // This is necessary for dynamic updates or modifications by compute shaders.
            texture.enableRandomWrite = true;
            texture.Create();
        }
        // Setting wrap mode to Repeat allows the texture coordinates to exceed the 0-1 range,
        // causing the texture to tile or repeat across the surface it's applied to.
        texture.wrapMode = TextureWrapMode.Repeat;

        // Bilinear for smoother texture sampling, which helps in minimizing artifacts when the texture is scaled or transformed.
        texture.filterMode = FilterMode.Bilinear;

        texture.name = name;
    }

    // Initializes the GPU based ComputeBuffers as well as a CPU Based buffer 
    // The compute shader buffers for allocating memory on the GPU, it's essential to specify exactly how much memory each element in the buffer will require.
    // The GPU needs this information to manage its memory resources effectively.
    // Stride = the size (in bytes) of one element in the array
    void CreateBuffers()
    {
        //-1 because a x,y,z grid with 1 point per axis would not have any voxels
        int numVoxelsPerAxis = numDensityPointPerChunkAxis - 1;

        //Cubing the number of voxels per axis.
        int totalNumberOfVoxels = numVoxelsPerAxis * numVoxelsPerAxis * numVoxelsPerAxis;

        //Marching Cubes algorithm can generate up to 5 triangles per voxel in the worst-case scenario
        int maxTriangleCount = totalNumberOfVoxels * 5;

        //Each triangle is made up of 3 vertices
        int maxVertexCount = maxTriangleCount * 3;

        //Create GPU buffers
        //Stores the number of triangles generated by the Marching Cubes algorithm, a single integer
        triCountBuffer = new ComputeBuffer(1, sizeof(int), ComputeBufferType.Raw);

        //A larger buffer to store the vertices of the triangles. Its size depends on the maximum number of triangles that can be generate
        triangleBuffer = new ComputeBuffer(maxVertexCount, ComputeHelper.GetStride<VertexData>(), ComputeBufferType.Append);

        //CPU Based Buffer An array to store the vertex data, which is then used for mesh construction.
        vertexDataArray = new VertexData[maxVertexCount];
    }

	// Creates the chunks that will be used to render the terrain
    void CreateChunks()
    {
        chunkArray = new Chunk[chunksPerDimension * chunksPerDimension * chunksPerDimension];

        float chunkSize = (terrainBoundarySize) / chunksPerDimension;
        int i = 0;

        for (int y = 0; y < chunksPerDimension; y++)
        {
            for (int x = 0; x < chunksPerDimension; x++)
            {
                for (int z = 0; z < chunksPerDimension; z++)
                {
                    Vector3Int coord = new Vector3Int(x, y, z);
                    float posX = (-(chunksPerDimension - 1f) / 2 + x) * chunkSize;
                    float posY = (-(chunksPerDimension - 1f) / 2 + y) * chunkSize;
                    float posZ = (-(chunksPerDimension - 1f) / 2 + z) * chunkSize;
                    Vector3 centre = new Vector3(posX, posY, posZ);

                    GameObject meshHolder = new GameObject($"Chunk ({x}, {y}, {z})");
                    meshHolder.transform.parent = transform;
                    meshHolder.layer = LayerMask.NameToLayer("Terrain");

                    Chunk chunk = new Chunk(coord, centre, chunkSize, numDensityPointPerChunkAxis, meshHolder);
                    chunk.SetMaterial(material);
                    chunkArray[i] = chunk;
                    i++;
                }
            }
        }
    }

    //Use density compute shader to generate the density values for each point in the 3D terrain texture
	//Then Loop through each chunk in chunkArray  and generate the mesh and print the timers
    void GenerateAllChunks()
	{
        // Stopwatch timers:
        timer_fetchVertexData = new System.Diagnostics.Stopwatch();
		timer_processVertexData = new System.Diagnostics.Stopwatch();

		// Use compute shader to generate density values
		ComputeDensity();

		//Generate mesh for each chunk
		for (int i = 0; i < chunkArray.Length; i++) {
			GenerateChunk(chunkArray[i]);
		}

        Debug.Log("Total Triangles " + totalTriangleCount);
        Debug.Log("Total Verticies " + totalVerticesCount);
        Debug.Log("Fetch vertex data: " + timer_fetchVertexData.ElapsedMilliseconds + " ms");
		Debug.Log("Process vertex data: " + timer_processVertexData.ElapsedMilliseconds + " ms");
		Debug.Log("Sum: " + (timer_fetchVertexData.ElapsedMilliseconds + timer_processVertexData.ElapsedMilliseconds) + " ms");
	}

	//Set the varaibles for the density compute shader and dispatch it using the helper class to get the raw density map
	//Afterwords if blurMap is true then call ProcessDensityMap() to blur the density map
	void ComputeDensity()
	{
		// Get points (each point is a vector4: xyz = position, w = density)
		int textureSize = rawDensityTexture.width;

		//Set Density ompute shader parameters
		densityCompute.SetInt("textureSize", textureSize);
		densityCompute.SetFloat("planetSize", terrainBoundarySize);
		densityCompute.SetFloat("noiseHeightMultiplier", noiseHeightMultiplier);
		densityCompute.SetFloat("noiseScale", noiseScale);

        //Initialize the debug buffer
        int bufferSize = 1000;
        ComputeBuffer debugBuffer = new ComputeBuffer(bufferSize, sizeof(float));
        densityCompute.SetBuffer(0, "debugBuffer", debugBuffer);

        //Dispatch the density compute shader
        ComputeHelper.Dispatch(densityCompute, textureSize, textureSize, textureSize);

        //Read debug values.
        float[] debugData = new float[bufferSize];
        debugBuffer.GetData(debugData);
        debugBuffer.Release();
        Debug.Log(debugData);

        ProcessDensityMap();
	}

	//If blurMap is true, calculate the processed density map by blurring the raw density map
	void ProcessDensityMap()
	{
		if (blurMap)
		{
			int size = rawDensityTexture.width;
			blurCompute.SetInts("brushCentre", 0, 0, 0);
			blurCompute.SetInt("blurRadius", blurRadius);
			blurCompute.SetInt("textureSize", rawDensityTexture.width);
			ComputeHelper.Dispatch(blurCompute, size, size, size);
		}
	}

	// Generate the vertex data for the chunk after setting its coordinates into the mesh compute shader
	// Then creates the mesh using the vertex data
	void GenerateChunk(Chunk chunk)
	{
		int numVoxelsPerAxis = numDensityPointPerChunkAxis - 1;
		int marchKernel = 0;

        // Set mesh compute shader params and buffers
        Vector3 chunkCoord = (Vector3)chunk.id * (numDensityPointPerChunkAxis - 1);
        meshCompute.SetVector("chunkCoord", chunkCoord);
        meshCompute.SetInt("textureSize", processedDensityTexture.width);
		meshCompute.SetInt("numPointsPerAxis", numDensityPointPerChunkAxis);
		meshCompute.SetFloat("isoLevel", isoLevel);
		meshCompute.SetFloat("planetSize", terrainBoundarySize);
		triangleBuffer.SetCounterValue(0);
		meshCompute.SetBuffer(marchKernel, "triangles", triangleBuffer);

		// Dispatch mesh compute shader and generate the vertex data for the mesh
		ComputeHelper.Dispatch(meshCompute, numVoxelsPerAxis, numVoxelsPerAxis, numVoxelsPerAxis, marchKernel);

        // Fetch vertex Count from GPU
        // Using an intermediate buffer (triCountBuffer) and a specialized copy operation to efficiently and accurately transfer vertexCountData from the GPU to the CPU
        // Retrieves the count of elements from triangleBuffer and places it into triCountBuffer
        int[] triangleCountData = new int[1];
		triCountBuffer.SetData(triangleCountData);
		ComputeBuffer.CopyCount(triangleBuffer, triCountBuffer, 0);

        // Fetch vertex data from GPU
        // Use the count we got from the GPU to retrieve the vertex data from triangleBuffer (GPU) and place it into vertexDataArray (CPU)
        timer_fetchVertexData.Start();
		triCountBuffer.GetData(triangleCountData);
		int numVertices = triangleCountData[0] * 3;
        triangleBuffer.GetData(vertexDataArray, 0, 0, numVertices);
		timer_fetchVertexData.Stop();

        // Update debug info
        totalVerticesCount += numVertices;
        totalTriangleCount += triangleCountData[0];

        // Create the mesh using the vertex data
        timer_processVertexData.Start();
		chunk.CreateMesh(vertexDataArray, numVertices, useFlatShading); //TODO: understand
		timer_processVertexData.Stop();
	}

	void Update()
	{
		// TODO: move somewhere more sensible
		material.SetTexture("DensityTex", originalMap);
		material.SetFloat("planetBoundsSize", terrainBoundarySize);
	}


	void ReleaseBuffers(){
		ComputeHelper.Release(triangleBuffer, triCountBuffer);
	}

	void OnDestroy()
	{
		ReleaseBuffers();
		foreach (Chunk chunk in chunkArray)
		{
			chunk.Release();
		}
	}

    void DrawDebugCircle(Vector3 center, float radius)
    {
        int segments = 360; // More segments mean a smoother circle
        float angle = 0f;

        for (int i = 0; i <= segments; i++)
        {
            float x = Mathf.Sin(Mathf.Deg2Rad * angle) * radius;
            float z = Mathf.Cos(Mathf.Deg2Rad * angle) * radius;
            Vector3 start = new Vector3(center.x + x, center.y, center.z + z);

            angle += (360f / segments);
            float nextX = Mathf.Sin(Mathf.Deg2Rad * angle) * radius;
            float nextZ = Mathf.Cos(Mathf.Deg2Rad * angle) * radius;
            Vector3 end = new Vector3(center.x + nextX, center.y, center.z + nextZ);

            Debug.DrawLine(start, end, Color.red, 5f); // Red color, 5-second duration
        }
    }

    void OnDrawGizmos()
    {
        // Set the Gizmo color
        Gizmos.color = Color.red;

        // Draw the sphere
        Gizmos.DrawWireSphere(gizmoPosition, gizmoRadius);
    }

    public void Terraform(Vector3 point, float weight, float radius)
	{
        //Determining the size of each voxel in your 3D texture in terms of Unity world units
        int editTextureSize = rawDensityTexture.width; //number of voxels along one axis of the grid + 1

        // Take terrain unity/world units axis lenth (i.e. 500), divide it by the textureAxisLenth (number of density points for each axis in the texture)
        // This gives us the size of each voxel in world units (The distance of each density point to the next, on each axis world units)
        float voxelSizeInWorldUnits = terrainBoundarySize / editTextureSize;

        //The radius in terms of how many voxels it spans.
        int editRadius = Mathf.CeilToInt(radius / voxelSizeInWorldUnits);

        //Transform the input world space point to texture space. 
        //Normalizing the world space coordinates within the bounds of your terrain, effectively mapping a world space point to a proportion of your terrain's total size.
        float tx = Mathf.Clamp01((point.x + terrainBoundarySize / 2) / terrainBoundarySize);
		float ty = Mathf.Clamp01((point.y + terrainBoundarySize / 2) / terrainBoundarySize);
		float tz = Mathf.Clamp01((point.z + terrainBoundarySize / 2) / terrainBoundarySize);
        //Takes these normalized proportions and maps them to specific voxel grid coordinates
        int editX = Mathf.RoundToInt(tx * (editTextureSize - 1));
		int editY = Mathf.RoundToInt(ty * (editTextureSize - 1));
		int editZ = Mathf.RoundToInt(tz * (editTextureSize - 1));

		//Set the parameters for the edit compute shader
		editCompute.SetFloat("weight", weight);
		editCompute.SetFloat("deltaTime", Time.deltaTime);
		editCompute.SetInts("brushCentre", editX, editY, editZ);
		editCompute.SetInt("brushRadius", editRadius);
		editCompute.SetInt("size", editTextureSize);

        //Update the texture using the shader.
        //Dispatch the edit compute shader to modify the density values in the 3D texture
        //This outputs to the rawDensityTexture -- editCompute.SetTexture(0, "EditTexture", rawDensityTexture);
        //Since editCompute and densityCompute both use rawDensityTexture, it has access to the all the density values already.
        //So this just edits the existsing values based on the brush size, weight, and position etc
        ComputeHelper.Dispatch(editCompute, editTextureSize, editTextureSize, editTextureSize);

		int size = rawDensityTexture.width;

		if (blurMap){
			blurCompute.SetInt("textureSize", rawDensityTexture.width);
			blurCompute.SetInts("brushCentre", editX - blurRadius - editRadius, editY - blurRadius - editRadius, editZ - blurRadius - editRadius);
			blurCompute.SetInt("blurRadius", blurRadius);
			blurCompute.SetInt("brushRadius", editRadius);
			int k = (editRadius + blurRadius) * 2;
			ComputeHelper.Dispatch(blurCompute, k, k, k);
		}

		float worldRadius = (editRadius + 1 + ((blurMap) ? blurRadius : 0)) * voxelSizeInWorldUnits;
        //Debug the sphere
        gizmoPosition = point;
        gizmoRadius = worldRadius;

        //Loop through each chunk and check if it intersects with the sphere defined by the input point and radius
        //If it does, then regenerate the mesh for that chunk to reflect the new density values
        for (int i = 0; i < chunkArray.Length; i++){
			Chunk chunk = chunkArray[i];
			if (MathUtility.SphereIntersectsBox(point, worldRadius, chunk.centre, Vector3.one * chunk.size)){
				GenerateChunk(chunk);
			}
		}
	}
}